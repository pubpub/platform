// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "tracing", "omitApi"]
}

generator dbml {
  provider = "prisma-dbml-generator"
  output   = "."
}

generator comments {
  provider = "pnpm exec tsx prisma/comment-generator.ts"
}

model User {
  id           String   @id @default(dbgenerated("gen_random_uuid()"))
  slug         String   @unique
  email        String   @unique
  firstName    String
  lastName     String?
  orcid        String?
  avatar       String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  isSuperAdmin Boolean  @default(false)
  passwordHash String?

  memberGroups         MemberGroup[]
  AuthToken            AuthToken[]
  assignedPubs         Pub[]
  actionRuns           ActionRun[]
  ApiAccessToken       ApiAccessToken[]
  Session              Session[]
  formMemberships      FormMembership[]
  communityMemberships CommunityMembership[]
  pubMemberships       PubMembership[]
  stageMemberships     StageMembership[]

  @@map(name: "users")
}

model Session {
  id        String        @id @default(dbgenerated("gen_random_uuid()"))
  userId    String
  user      User          @relation(fields: [userId], references: [id])
  expiresAt DateTime
  /// With what type of token is this session created? Used for determining on a page-by-page basis whether to allow a certain session to access it. For instance, a verify email token/session should not allow you to access the password reset page.
  type      AuthTokenType @default(generic)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@map(name: "sessions")
}

model AuthToken {
  id        String        @id @default(dbgenerated("gen_random_uuid()"))
  hash      String
  createdAt DateTime      @default(now())
  expiresAt DateTime // Tokens expire within 1 week...
  isUsed    Boolean       @default(false) // ...or after one use
  user      User          @relation(fields: [userId], references: [id])
  userId    String
  type      AuthTokenType @default(generic)

  @@map(name: "auth_tokens")
}

/// @property generic - For most use-cases. This will just authenticate you with a regular session.
/// @property passwordReset - For resetting your password only
/// @property signup - For signing up, but also when you're invited to a community
/// @property verifyEmail - For verifying your email address
enum AuthTokenType {
  generic
  passwordReset
  signup
  verifyEmail
}

model Community {
  id        String   @id @default(dbgenerated("gen_random_uuid()"))
  name      String
  slug      String   @unique
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  pubTypes             PubType[]
  pubs                 Pub[]
  integrationInstances IntegrationInstance[]
  memberGroups         MemberGroup[]
  stages               Stage[]
  APIAccessToken       ApiAccessToken[]
  Form                 Form[]
  pubFields            PubField[]
  members              CommunityMembership[]

  @@map(name: "communities")
}

model Pub {
  id          String    @id @default(dbgenerated("gen_random_uuid()"))
  valuesBlob  Json?
  pubType     PubType   @relation(fields: [pubTypeId], references: [id])
  pubTypeId   String
  community   Community @relation(fields: [communityId], references: [id])
  communityId String
  assigneeId  String?
  assignee    User?     @relation(fields: [assigneeId], references: [id])
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now()) @updatedAt

  parent   Pub?    @relation("pub_parent", fields: [parentId], references: [id], onDelete: Cascade)
  parentId String?
  children Pub[]   @relation("pub_parent")

  values                   PubValue[]                 @relation("original_pub")
  stages                   PubsInStages[]
  integrationInstances     IntegrationInstance[]
  IntegrationInstanceState IntegrationInstanceState[]
  actionRuns               ActionRun[]
  relatedValues            PubValue[]                 @relation("related_pub")
  members                  PubMembership[]

  @@map(name: "pubs")
}

model PubField {
  id               String          @id @default(dbgenerated("gen_random_uuid()"))
  name             String
  slug             String          @unique
  integration      Integration?    @relation(fields: [integrationId], references: [id])
  integrationId    String?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @default(now()) @updatedAt
  schema           PubFieldSchema? @relation(fields: [pubFieldSchemaId], references: [id])
  schemaName       CoreSchemaType?
  pubFieldSchemaId String?
  isArchived       Boolean         @default(false)
  community        Community       @relation(fields: [communityId], references: [id])
  communityId      String
  isRelation       Boolean         @default(false)

  values    PubValue[]
  pubTypes  PubFieldToPubType[]
  FormInput FormElement[]

  @@map(name: "pub_fields")
}

enum CoreSchemaType {
  Boolean
  DateTime
  Email
  FileUpload
  MemberId
  Null
  Number
  NumericArray
  RichText
  String
  StringArray
  URL
  Vector3
}

model PubFieldSchema {
  id        String   @id @default(dbgenerated("gen_random_uuid()"))
  namespace String
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // This must be a dereferenced JSONSchema. We should find a way to validate.
  schema    Json /// @type(JSONSchemaType<any>, 'ajv', true, false, true)
  PubFields PubField[]

  @@unique([name, namespace], name: "schema_identifier")
}

model PubValue {
  id           String   @id @default(dbgenerated("gen_random_uuid()"))
  field        PubField @relation(fields: [fieldId], references: [id])
  fieldId      String
  value        Json?
  pub          Pub      @relation(fields: [pubId], references: [id], onDelete: Cascade, name: "original_pub")
  pubId        String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  relatedPub   Pub?     @relation(fields: [relatedPubId], references: [id], onDelete: Cascade, name: "related_pub")
  relatedPubId String?

  // Add userId and integrationId to track who created the value

  @@map(name: "pub_values")
}

model PubType {
  id          String    @id @default(dbgenerated("gen_random_uuid()"))
  name        String
  description String?
  community   Community @relation(fields: [communityId], references: [id])
  communityId String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now()) @updatedAt

  fields PubFieldToPubType[]
  pubs   Pub[]
  Form   Form[]

  @@map(name: "pub_types")
}

model PubFieldToPubType {
  A       String
  B       String
  isTitle Boolean @default(false)

  pubField PubField @relation(fields: [A], references: [id], onUpdate: Cascade, onDelete: Cascade)
  pubType  PubType  @relation(fields: [B], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@unique([A, B], name: "_PubFieldToPubType_AB_unique")
  @@index([B], name: "_PubFieldToPubType_B_index")
  @@map(name: "_PubFieldToPubType")
}

model Stage {
  id          String    @id @default(dbgenerated("gen_random_uuid()"))
  name        String
  order       String
  community   Community @relation(fields: [communityId], references: [id])
  communityId String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now()) @updatedAt

  pubs                  PubsInStages[]
  moveConstraints       MoveConstraint[]      @relation("move_constraint")
  moveConstraintSources MoveConstraint[]      @relation("move_constraint_destination")
  integrationInstances  IntegrationInstance[]
  actionInstances       ActionInstance[]
  formElements          FormElement[]
  members               StageMembership[]

  @@map(name: "stages")
}

model PubsInStages {
  pub     Pub    @relation(fields: [pubId], references: [id], onDelete: Cascade)
  pubId   String
  stage   Stage  @relation(fields: [stageId], references: [id], onDelete: Cascade)
  stageId String

  @@id([pubId, stageId])
}

model MoveConstraint {
  stage         Stage    @relation("move_constraint", fields: [stageId], references: [id], onDelete: Cascade)
  stageId       String
  destination   Stage    @relation("move_constraint_destination", fields: [destinationId], references: [id], onDelete: Cascade)
  destinationId String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @default(now()) @updatedAt

  @@id([stageId, destinationId], name: "moveConstraintId")
  @@map(name: "move_constraint")
}

enum MemberRole {
  // community-wide administrator
  admin
  // regular member
  editor
  // contributor
  contributor
}

model MemberGroup {
  id          String    @id @default(dbgenerated("gen_random_uuid()"))
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now()) @updatedAt

  users                User[]
  formMemberships      FormMembership[]
  communityMemberships CommunityMembership[]
  pubMemberships       PubMembership[]
  stageMemberships     StageMembership[]

  @@map(name: "member_groups")
}

model CommunityMembership {
  id            String       @id @default(dbgenerated("gen_random_uuid()"))
  role          MemberRole
  community     Community    @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId   String
  user          User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String?
  memberGroup   MemberGroup? @relation(fields: [memberGroupId], references: [id], onDelete: Cascade)
  memberGroupId String?
  // This table has a check constraint requiring that exactly one of userId or memberGroupId is set
  // See core/prisma/migrations/20241017223037_add_new_membership_tables/migration.sql for details
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @default(now()) @updatedAt

  @@unique([communityId, userId])
  @@unique([communityId, memberGroupId])
  @@map(name: "community_memberships")
}

model PubMembership {
  id            String       @id @default(dbgenerated("gen_random_uuid()"))
  role          MemberRole
  pub           Pub          @relation(fields: [pubId], references: [id], onDelete: Cascade)
  pubId         String
  user          User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String?
  memberGroup   MemberGroup? @relation(fields: [memberGroupId], references: [id], onDelete: Cascade)
  memberGroupId String?
  // This table has a check constraint requiring that exactly one of userId or memberGroupId is set
  // See core/prisma/migrations/20241017223037_add_new_membership_tables/migration.sql for details
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @default(now()) @updatedAt

  @@unique([pubId, userId])
  @@unique([pubId, memberGroupId])
  @@map(name: "pub_memberships")
}

model StageMembership {
  id            String       @id @default(dbgenerated("gen_random_uuid()"))
  role          MemberRole
  stage         Stage        @relation(fields: [stageId], references: [id], onDelete: Cascade)
  stageId       String
  user          User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String?
  memberGroup   MemberGroup? @relation(fields: [memberGroupId], references: [id], onDelete: Cascade)
  memberGroupId String?
  // This table has a check constraint requiring that exactly one of userId or memberGroupId is set
  // See core/prisma/migrations/20241017223037_add_new_membership_tables/migration.sql for details
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @default(now()) @updatedAt

  @@unique([stageId, userId])
  @@unique([stageId, memberGroupId])
  @@map(name: "stage_memberships")
}

model FormMembership {
  id            String       @id @default(dbgenerated("gen_random_uuid()"))
  // Unlike other membership tables, form memberships don't have a role (yet)
  form          Form         @relation(fields: [formId], references: [id], onDelete: Cascade)
  formId        String
  user          User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String?
  memberGroup   MemberGroup? @relation(fields: [memberGroupId], references: [id], onDelete: Cascade)
  memberGroupId String?
  // This table has a check constraint requiring that exactly one of userId or memberGroupId is set
  // See core/prisma/migrations/20241017223037_add_new_membership_tables/migration.sql for details
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @default(now()) @updatedAt

  @@unique([formId, userId])
  @@unique([formId, memberGroupId])
  @@map(name: "form_memberships")
}

model Integration {
  id          String   @id @default(dbgenerated("gen_random_uuid()"))
  name        String
  actions     Json
  settingsUrl String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  instances IntegrationInstance[]
  pubFields PubField[]

  @@map(name: "integrations")
}

model IntegrationInstance {
  id            String      @id @default(dbgenerated("gen_random_uuid()"))
  name          String
  integration   Integration @relation(fields: [integrationId], references: [id])
  integrationId String
  community     Community   @relation(fields: [communityId], references: [id])
  communityId   String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @default(now()) @updatedAt
  stage         Stage?      @relation(fields: [stageId], references: [id])
  stageId       String?
  config        Json?

  pubs                     Pub[]
  IntegrationInstanceState IntegrationInstanceState[]

  @@map(name: "integration_instances")
}

model IntegrationInstanceState {
  pub        Pub                 @relation(fields: [pubId], references: [id])
  pubId      String
  instance   IntegrationInstance @relation(fields: [instanceId], references: [id])
  instanceId String
  state      Json

  @@unique([pubId, instanceId], name: "pub_instance")
}

model ActionInstance {
  id        String      @id @default(dbgenerated("gen_random_uuid()"))
  name      String      @default("")
  action    Action
  stage     Stage       @relation(fields: [stageId], references: [id], onDelete: Cascade)
  stageId   String
  createdAt DateTime    @default(now())
  updatedAt DateTime    @default(now()) @updatedAt
  config    Json?
  rules     Rule[]
  runs      ActionRun[]

  @@map(name: "action_instances")
}

enum Action {
  log
  pdf
  email
  pushToV6
  http
  move
  googleDriveImport
}

model ActionRun {
  id               String          @id @default(dbgenerated("gen_random_uuid()"))
  actionInstance   ActionInstance? @relation(fields: [actionInstanceId], references: [id], onDelete: Cascade)
  actionInstanceId String?
  pub              Pub?            @relation(fields: [pubId], references: [id])
  pubId            String?
  config           Json?
  event            Event?
  params           Json?
  status           ActionRunStatus
  result           Json
  user             User?           @relation(fields: [userId], references: [id])
  userId           String?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @default(now()) @updatedAt

  @@map(name: "action_runs")
}

enum ActionRunStatus {
  scheduled
  success
  failure
}

model Rule {
  id               String         @id @default(dbgenerated("gen_random_uuid()"))
  event            Event
  actionInstance   ActionInstance @relation(fields: [actionInstanceId], references: [id], onDelete: Cascade)
  actionInstanceId String
  config           Json?

  @@unique([actionInstanceId, event])
  @@map(name: "rules")
}

enum Event {
  pubEnteredStage
  pubLeftStage
  pubInStageForDuration
}

enum FormAccessType {
  private
  inviteOnly
  public
}

model Form {
  id          String         @id @default(dbgenerated("gen_random_uuid()"))
  name        String
  slug        String
  communityId String
  community   Community      @relation(fields: [communityId], references: [id], onDelete: Cascade)
  pubType     PubType        @relation(fields: [pubTypeId], references: [id])
  pubTypeId   String
  elements    FormElement[]
  isArchived  Boolean        @default(false)
  access      FormAccessType @default(private)
  isDefault   Boolean        @default(false)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @default(now()) @updatedAt

  members FormMembership[]

  @@unique([name, communityId])
  @@unique([slug, communityId])
  @@map(name: "forms")
}

// Supported structural elements in the form builder
enum StructuralFormElement {
  h2
  h3
  p
  hr
}

enum ElementType {
  pubfield
  structural
  button
}

enum InputComponent {
  textArea
  textInput
  datePicker
  checkbox
  fileUpload
  memberSelect
  confidenceInterval
  checkboxGroup
  radioGroup
  richText
  selectDropdown
  multivalueInput
}

// Either a structural element like a header, hr etc. or a pubfield input
model FormElement {
  id        String                 @id @default(dbgenerated("gen_random_uuid()"))
  type      ElementType
  fieldId   String?
  field     PubField?              @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  formId    String
  order     Int?
  // label is only used by elements with type: ElementType.button. Pubfield inputs put everything in config
  label     String?
  element   StructuralFormElement?
  component InputComponent?
  config    Json?
  content   String?
  required  Boolean?
  form      Form                   @relation(fields: [formId], references: [id], onDelete: Cascade)
  stage     Stage?                 @relation(fields: [stageId], references: [id], onDelete: SetNull)
  stageId   String?

  @@unique([type, label, formId])
  @@unique([fieldId, formId])
  @@map(name: "form_elements")
}

model ApiAccessToken {
  id          String                @id @default(dbgenerated("gen_random_uuid()"))
  token       String                @unique
  name        String
  description String?
  communityId String
  community   Community             @relation(fields: [communityId], references: [id])
  expiration  DateTime
  issuedBy    User                  @relation(fields: [issuedById], references: [id])
  issuedById  String
  issuedAt    DateTime              @default(now())
  accessRules ApiAccessPermission[]
  logs        ApiAccessLog[]

  @@index([token], name: "token_idx")
  @@map(name: "api_access_tokens")
}

model ApiAccessLog {
  id            String         @id @default(dbgenerated("gen_random_uuid()"))
  accessTokenId String
  accessToken   ApiAccessToken @relation(fields: [accessTokenId], references: [id])
  timestamp     DateTime       @default(now())
  action        String

  @@map(name: "api_access_logs")
}

enum ApiAccessType {
  read
  write
  archive
}

// A permission existing for a scope means that the user has access to that scope
// notwithstanding the contraints
model ApiAccessPermission {
  id               String         @id @default(dbgenerated("gen_random_uuid()"))
  apiAccessTokenId String
  apiAccessToken   ApiAccessToken @relation(fields: [apiAccessTokenId], references: [id])
  scope            ApiAccessScope
  accessType       ApiAccessType
  constraints      Json? /// @type(ApiAccessPermissionConstraints, '../types', true, false, true)

  // this ensures that only one permission per token and scope and access type exists
  @@index([apiAccessTokenId, scope, accessType], name: "api_access_permissions_idx")
  @@map(name: "api_access_permissions")
}

enum ApiAccessScope {
  community
  pub
  stage
  member
  pubType
}

enum Capabilities {
  movePub
  createPub
  viewPub
  deletePub
  updatePubValues
  createRelatedPub
  createPubWithForm
  editPubWithForm
  createPubField
  archivePubField
  editPubField
  createPubType
  editPubType
  deletePubType
  runAction
  viewStage
  createStage
  manageStage // includes managing stage name, actions, rules, and move constraints
  deleteStage
  addPubMember
  removePubMember
  addStageMember
  removeStageMember
  addFormMember
  removeFormMember
  addCommunityMember
  removeCommunityMember
  manageMemberGroups
  addCommunity
  editCommunity
  createForm
  editForm
  archiveForm
  createApiToken
  revokeApiToken
}

enum MembershipType {
  community
  stage
  pub
  form
}

model MembershipCapabilities {
  role       MemberRole
  type       MembershipType
  capability Capabilities

  @@id([role, type, capability])
  @@map(name: "membership_capabilities")
}
