# Kysely

## Documentation

As we start replacing Prisma with Kysely, here are some resources that may help:

-   Kysely's high-level docs are very useful for writing simple queries, including joining/querying related tables and returning the results as nested json (like an ORM)
    -   Make sure to look at the [Examples](https://kysely.dev/docs/category/examples) and [Recipes](https://kysely.dev/docs/category/recipes)
-   When it comes to more complicated queries, or for extracting helper functions, those docs can be a little bit lacking
    -   Kysely's API reference docs have a fair amount of documentation contained within them (also available via intellisense). See especially the [SelectQueryBuilder](https://kysely-org.github.io/kysely-apidoc/interfaces/SelectQueryBuilder.html), [ExpressionBuilder](https://kysely-org.github.io/kysely-apidoc/interfaces/ExpressionBuilder.html), and [QueryCreator](https://kysely-org.github.io/kysely-apidoc/classes/QueryCreator.html) interfaces.
    -   Beyond that, their [Discord](https://discord.gg/xyBJ3GwvAm) is active and has a searchable Q/A history with many practical examples. Searching the [Kysely github](https://github.com/kysely-org/kysely) will also often turn up examples for how to use particular methods.
-   It will be at least as important to understand PostgreSQL to use Kysely effectively. The [postgres docs](https://www.postgresql.org/docs/15/index.html) are useful for reviewing SQL basics and as reference documentation for the many functions we'll use.

## Type Generation

The files in the [types](./types) directory are generated by running `pnpm make-kysely-types`, which connects to the database specified by the `DATABASE_URL` var, introspects the schema, and then writes updated types to your local filesystem. These types are committed to the repo and must be updated alongside any migration. Since we are currently still using Prisma to manage our schema, this means you should always generate these types from your local database after creating and running a new migration.

We use Kanel to generate these types, which can be configured via [.kanelrc.js](../.kanelrc.js). Configuration options can be found in the [Kanel docs](https://kristiandupont.github.io/kanel/configuring.html).

### Generating types for JSON fields

> [!NOTE]
> You might need to run `pnpm --filter core migrate-dev` twice to get the types to update properly.

It is possible to generate more specific types for JSON fields defined.

This is done in the Prisma schema, by adding an annotation to the field which will add a comment to the database.

https://github.com/pubpub/v7/blob/e99c9cb0eec498a9a7a2a2622f294f42bfd8e8b2/core/prisma/schema.prisma#L392

Adding a `///` will add the string as a comment to that column in the database using a custom generator defined here:

https://github.com/pubpub/v7/blob/e99c9cb0eec498a9a7a2a2622f294f42bfd8e8b2/core/prisma/schema.prisma#L14-L16

This will lead to the following migration:
https://github.com/pubpub/v7/blob/0e7ad15ea0ecd08b86133fde9a7ecb6075941da7/core/prisma/migrations/20240523130939_update_comments/migration.sql#L85

This comment then gets picked up by Kanel and turned into a type definition for the field.

The syntax (largely undocumented, except for here https://github.com/kristiandupont/kanel/issues/429#issuecomment-1636126264), is:

```
@type(name, path, isAbsolute, isDefault, importAsType)
```

So

```prisma
config           Json? /// @type(RuleConfigs, '~/actions/types', true, false, true)
```

will generate the following type:

```ts
import type { RuleConfigs } from "~/actions/types";

// ...

config: RuleConfigs | null;
// ...
```

Alernatively, you can also specify a type directly:

```prisma
config           Json? /// @type:string
```

or use global types

```prisma
config           Json? /// @type:DBTypes.RuleConfig
```

and then specify those types in some file like `globals.ts`:

```ts
declare global {
	namespace DBTypes {
		type RuleConfig = {
			// ...
		};
	}
}

// necessary to make `declare global` work with or without using `import`s
export {};
```

## Maintainability

It's easy to end up with a mess of SQL functions in a variety of ways (too many helper functions, helpers are too complex, too much duplication) and there aren't any silver bullets to prevent that. As we develop patterns that serve us well we will document them here. For now, be attentive to the number of queries being run in a single request and try to strike a balance between readability, composability, and efficiency as we rewrite our queries and factor out common functionality. On a practical note, consider using the [`clearSelect`](https://kysely-org.github.io/kysely-apidoc/interfaces/SelectQueryBuilder.html#clearSelect), [`clearWhere`](https://kysely-org.github.io/kysely-apidoc/interfaces/SelectQueryBuilder.html#clearWhere) and similar methods when attempting to customize an existing helper function, instead of modifying the function.
